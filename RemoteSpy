-- Remote Spy v5.2 | Fixed Hook Engine + Function Info + Lag Fixes
--[[
    FIXES IN v5.2:
    [1] Removed checkcaller() guard ‚Äî was silently dropping real game remote fires
    [2] getrawmetatable fallback if hookmetamethod is missing
    [3] hookfunction() backup on FireServer / InvokeServer directly
    [4] Case variants handled: fireServer / invokeServer
    [5] Function Info panel added (name, source, line, constants)
    [6] Lag fixes: capped log entries, batched canvas updates, 
        deferred UI builds off main thread, pooled unused rows
]]

--------------------------------------------------------------------------------
-- SERVICES
--------------------------------------------------------------------------------
local HttpService       = game:GetService("HttpService")
local Players           = game:GetService("Players")
local TweenService      = game:GetService("TweenService")
local UserInputService  = game:GetService("UserInputService")
local RunService        = game:GetService("RunService")
local LP                = Players.LocalPlayer

--------------------------------------------------------------------------------
-- CONSTANTS
--------------------------------------------------------------------------------
local VERSION          = "5.2"
local MAX_HISTORY      = 500
local DEDUPE_WINDOW    = 0.35
local FIRE_RATE_LIMIT  = 0.2
local SCROLL_THRESH    = 80
local MAX_EXEC_LOG     = 20
local MAX_LOG_ENTRIES  = 300   -- LAG FIX: cap visible rows
local CANVAS_DEBOUNCE  = 0.05  -- LAG FIX: batch canvas resizes

--------------------------------------------------------------------------------
-- THEME
--------------------------------------------------------------------------------
local T = {
    BG           = Color3.fromRGB(12, 12, 14),
    BG2          = Color3.fromRGB(18, 18, 22),
    BG3          = Color3.fromRGB(24, 24, 30),
    BG4          = Color3.fromRGB(30, 30, 38),
    BORDER       = Color3.fromRGB(45, 45, 58),
    BORDER2      = Color3.fromRGB(60, 60, 78),
    GREEN        = Color3.fromRGB(50, 210, 100),
    GREEN_DIM    = Color3.fromRGB(30, 140, 65),
    BLUE         = Color3.fromRGB(60, 140, 255),
    BLUE_DIM     = Color3.fromRGB(35, 80, 180),
    YELLOW       = Color3.fromRGB(255, 200, 60),
    RED          = Color3.fromRGB(220, 60, 60),
    PURPLE       = Color3.fromRGB(160, 80, 255),
    ORANGE       = Color3.fromRGB(220, 130, 30),
    TEXT         = Color3.fromRGB(210, 215, 225),
    TEXT_DIM     = Color3.fromRGB(130, 135, 150),
    TEXT_MUTED   = Color3.fromRGB(75, 78, 95),
    CODE         = Color3.fromRGB(100, 255, 140),
    ENTRY_IDLE   = Color3.fromRGB(22, 22, 27),
    ENTRY_HOVER  = Color3.fromRGB(28, 28, 35),
    ENTRY_SEL    = Color3.fromRGB(20, 50, 30),
    ENTRY_MULTI  = Color3.fromRGB(18, 30, 62),
    RE_CLR       = Color3.fromRGB(30, 110, 200),
    RF_CLR       = Color3.fromRGB(130, 50, 200),
    DIR_OUT      = Color3.fromRGB(200, 140, 30),
    DIR_IN       = Color3.fromRGB(30, 170, 160),
    FUNC_HDR     = Color3.fromRGB(80, 40, 160),
}

--------------------------------------------------------------------------------
-- STATE
--------------------------------------------------------------------------------
local spy = {
    hooked        = {},
    blocked       = {},
    paused        = false,
    entries       = {},
    entryMap      = {},
    totalCalls    = 0,
    selected      = nil,
    multiSel      = {},
    multiCount    = 0,
    lastClickIdx  = nil,
    history       = {},
    histIdx       = 0,
    lastFire      = 0,
    execLog       = {},
    loopConn      = nil,
    loopRunning   = false,
    filterText    = "",
    activeTab     = "log",
    dirFilter     = "all",
    -- LAG FIX: canvas update debounce
    canvasDirty   = false,
}

-- LAG FIX: pending log queue processed per-frame
local pendingLogs = {}

--------------------------------------------------------------------------------
-- UTILITY: UI BUILDERS
--------------------------------------------------------------------------------
local function corner(obj, r)
    local c = Instance.new("UICorner")
    c.CornerRadius = UDim.new(0, r or 6)
    c.Parent = obj
    return c
end

local function uiStroke(obj, col, thick)
    local s = Instance.new("UIStroke")
    s.Color     = col   or T.BORDER
    s.Thickness = thick or 1
    s.Parent    = obj
    return s
end

local function lbl(parent, txt, sz, col, font, xa, ya)
    local l = Instance.new("TextLabel")
    l.BackgroundTransparency = 1
    l.Text           = txt   or ""
    l.TextSize       = sz    or 13
    l.TextColor3     = col   or T.TEXT
    l.Font           = font  or Enum.Font.Gotham
    l.TextXAlignment = xa    or Enum.TextXAlignment.Left
    l.TextYAlignment = ya    or Enum.TextYAlignment.Center
    l.TextWrapped    = false
    l.Parent         = parent
    return l
end

local function btn(parent, txt, sz, col, font)
    local b = Instance.new("TextButton")
    b.BackgroundColor3 = col  or T.BG3
    b.Text             = txt  or ""
    b.TextSize         = sz   or 12
    b.TextColor3       = T.TEXT
    b.Font             = font or Enum.Font.GothamBold
    b.AutoButtonColor  = false
    b.BorderSizePixel  = 0
    b.Parent           = parent
    return b
end

local function tweenProp(obj, props, t, style, dir)
    TweenService:Create(obj,
        TweenInfo.new(t or 0.15, style or Enum.EasingStyle.Quad, dir or Enum.EasingDirection.Out),
        props):Play()
end

local function hoverBtn(b, hoverCol, baseCol)
    baseCol = baseCol or b.BackgroundColor3
    b.MouseEnter:Connect(function()  tweenProp(b, {BackgroundColor3 = hoverCol}) end)
    b.MouseLeave:Connect(function()  tweenProp(b, {BackgroundColor3 = baseCol})  end)
end

--------------------------------------------------------------------------------
-- UTILITY: ARG SNAPSHOT
--------------------------------------------------------------------------------
local function snap(...)
    local n, s = select("#", ...), {}
    for i = 1, n do s[i] = select(i, ...) end
    s.n = n
    return s
end

local function unsnap(s)
    return table.unpack(s, 1, s.n or #s)
end

--------------------------------------------------------------------------------
-- SERIALIZER
--------------------------------------------------------------------------------
local serialize

local function tryInstancePath(v)
    local ok, path = pcall(function()
        local parts, c = {}, v
        while c and c ~= game do
            table.insert(parts, 1, c.Name)
            c = c.Parent
        end
        if #parts == 0 then return "game" end
        local out = string.format('game:GetService("%s")', parts[1])
        for i = 2, #parts do
            out = out .. "." .. parts[i]
        end
        return out
    end)
    return ok and path or string.format('"[%s]"', v.ClassName)
end

serialize = function(v, depth, compact)
    depth   = depth   or 0
    compact = compact or false
    if depth > 7 then return '"[MaxDepth]"' end
    local t = typeof(v)
    if     t == "nil"     then return "nil"
    elseif t == "boolean" then return tostring(v)
    elseif t == "number"  then
        if v ~= v          then return "0/0"       end
        if v == math.huge  then return "math.huge"  end
        if v == -math.huge then return "-math.huge" end
        if v == math.floor(v) and math.abs(v) < 1e12 then
            return string.format("%d", v)
        end
        return string.format("%.6g", v)
    elseif t == "string" then
        return string.format("%q", v)
    elseif t == "table" then
        local maxn, kcount = 0, 0
        for k, _ in pairs(v) do
            kcount = kcount + 1
            if type(k) == "number" and k == math.floor(k) and k > 0 then
                maxn = math.max(maxn, k)
            end
        end
        local isPureArray = (maxn == kcount)
        local items, ind, und = {}, string.rep("    ", depth + 1), string.rep("    ", depth)
        if isPureArray then
            for i = 1, maxn do
                items[i] = serialize(v[i], depth + 1, compact)
            end
        else
            for k, val in pairs(v) do
                local key = (type(k) == "string" and k:match("^[%a_][%w_]*$"))
                    and k or ("[" .. serialize(k, depth + 1, compact) .. "]")
                table.insert(items, key .. " = " .. serialize(val, depth + 1, compact))
            end
        end
        local flat = "{" .. table.concat(items, ", ") .. "}"
        if compact or #flat <= 60 then return flat end
        return "{\n" .. ind .. table.concat(items, ",\n" .. ind) .. "\n" .. und .. "}"
    elseif t == "Vector2" then
        return string.format("Vector2.new(%s, %s)", serialize(v.X), serialize(v.Y))
    elseif t == "Vector3" then
        return string.format("Vector3.new(%s, %s, %s)", serialize(v.X), serialize(v.Y), serialize(v.Z))
    elseif t == "CFrame" then
        local p = v.Position
        local rx, ry, rz = v:ToEulerAnglesXYZ()
        return string.format("CFrame.new(%s, %s, %s) * CFrame.Angles(%s, %s, %s)",
            serialize(p.X), serialize(p.Y), serialize(p.Z),
            serialize(rx),  serialize(ry),  serialize(rz))
    elseif t == "Color3" then
        return string.format("Color3.fromRGB(%d, %d, %d)",
            math.round(v.R*255), math.round(v.G*255), math.round(v.B*255))
    elseif t == "UDim2" then
        return string.format("UDim2.new(%s, %s, %s, %s)",
            serialize(v.X.Scale), serialize(v.X.Offset),
            serialize(v.Y.Scale), serialize(v.Y.Offset))
    elseif t == "UDim" then
        return string.format("UDim.new(%s, %s)", serialize(v.Scale), serialize(v.Offset))
    elseif t == "Rect" then
        return string.format("Rect.new(%s, %s, %s, %s)",
            serialize(v.Min.X), serialize(v.Min.Y), serialize(v.Max.X), serialize(v.Max.Y))
    elseif t == "NumberRange" then
        return string.format("NumberRange.new(%s, %s)", serialize(v.Min), serialize(v.Max))
    elseif t == "NumberSequence" then
        local kps = {}
        for _, kp in ipairs(v.Keypoints) do
            table.insert(kps, string.format("NumberSequenceKeypoint.new(%s, %s, %s)",
                serialize(kp.Time), serialize(kp.Value), serialize(kp.Envelope)))
        end
        return "NumberSequence.new({" .. table.concat(kps, ", ") .. "})"
    elseif t == "ColorSequence" then
        local kps = {}
        for _, kp in ipairs(v.Keypoints) do
            table.insert(kps, string.format("ColorSequenceKeypoint.new(%s, %s)",
                serialize(kp.Time), serialize(kp.Value)))
        end
        return "ColorSequence.new({" .. table.concat(kps, ", ") .. "})"
    elseif t == "BrickColor" then
        return string.format("BrickColor.new(%q)", v.Name)
    elseif t == "EnumItem" then
        return string.format("Enum.%s.%s", tostring(v.EnumType), v.Name)
    elseif t == "Instance" then
        return tryInstancePath(v)
    elseif t == "TweenInfo" then
        return string.format("TweenInfo.new(%s, Enum.EasingStyle.%s, Enum.EasingDirection.%s, %s, %s, %s)",
            serialize(v.Time), v.EasingStyle.Name, v.EasingDirection.Name,
            serialize(v.RepeatCount), tostring(v.Reverses), serialize(v.DelayTime))
    else
        local ok, j = pcall(function() return HttpService:JSONEncode(v) end)
        return ok and j or string.format('"[%s]"', t)
    end
end

local function serializeArgs(args, compact)
    local parts = {}
    for i = 1, (args.n or #args) do
        parts[i] = serialize(args[i], 0, compact)
    end
    return table.concat(parts, ", ")
end

local function argPreview(args)
    local s = serializeArgs(args, true)
    if #s > 72 then s = s:sub(1, 69) .. "‚Ä¶" end
    return s
end

--------------------------------------------------------------------------------
-- PATH RESOLVER
--------------------------------------------------------------------------------
local function resolvePath(obj)
    local parts, cur = {}, obj
    while cur and cur ~= game do
        table.insert(parts, 1, cur.Name)
        cur = cur.Parent
    end
    if #parts == 0 then return "game" end
    local out = string.format('game:GetService("%s")', parts[1])
    for i = 2, #parts do
        out = out .. "." .. parts[i]
    end
    return out
end

--------------------------------------------------------------------------------
-- FUNCTION INFO CAPTURE
-- Safely pulls debug info from the calling stack when a remote fires
--------------------------------------------------------------------------------
local function captureFuncInfo()
    local info = {}
    -- Walk up stack looking for a non-C, non-spy frame
    for level = 3, 10 do
        local ok, di = pcall(debug.info or function() end, level, "snl")
        if not ok then break end
        if di then
            -- skip C functions and internal frames
            if type(di) == "string" then
                -- some executors return a string summary
                info.raw = di
                break
            end
        end
        -- standard debug.info with flags
        local ok2, name, src, line = pcall(function()
            return debug.info(level, "nsl")
        end)
        if ok2 and src and not src:find("RemoteSpy") then
            info.name   = (name ~= "") and name or "?"
            info.source = src
            info.line   = line
            break
        end
    end
    -- Also try getinfo for executors that expose it
    pcall(function()
        local di = debug.getinfo and debug.getinfo(4)
        if di then
            info.name   = info.name   or (di.name ~= "" and di.name or "?")
            info.source = info.source or di.short_src or di.source
            info.line   = info.line   or di.currentline
        end
    end)
    -- Pull constants from calling function if possible
    pcall(function()
        local f = debug.getinfo and debug.getinfo(4, "f")
        if f and f.func and islclosure and islclosure(f.func) then
            local consts = debug.getconstants(f.func)
            if consts and #consts > 0 then
                -- Only keep string/number constants, skip noise
                local filtered = {}
                for _, c in ipairs(consts) do
                    if type(c) == "string" or type(c) == "number" then
                        table.insert(filtered, c)
                    end
                end
                info.constants = filtered
            end
        end
    end)
    return info
end

local function formatFuncInfo(fi)
    if not fi then return "-- No function info captured." end
    local lines = {"-- ‚ïî‚ïê‚ïê FUNCTION INFO ‚ïê‚ïê‚ïó"}
    if fi.name   then table.insert(lines, "-- Name   : " .. tostring(fi.name))   end
    if fi.source then table.insert(lines, "-- Source : " .. tostring(fi.source)) end
    if fi.line   then table.insert(lines, "-- Line   : " .. tostring(fi.line))   end
    if fi.raw    then table.insert(lines, "-- Debug  : " .. tostring(fi.raw))    end
    if fi.constants and #fi.constants > 0 then
        table.insert(lines, "-- Constants:")
        for i, c in ipairs(fi.constants) do
            if i > 12 then table.insert(lines, "--   ... (" .. (#fi.constants - 12) .. " more)") break end
            table.insert(lines, "--   [" .. i .. "] = " .. serialize(c, 0, true))
        end
    end
    table.insert(lines, "-- ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
    return table.concat(lines, "\n")
end

--------------------------------------------------------------------------------
-- CODE GENERATION
--------------------------------------------------------------------------------
local function getCallerName(remoteType, direction, args)
    if direction == "IN" then
        if remoteType == "RemoteFunction" then return "Server ‚Üí " .. LP.Name end
        for i = 1, (args.n or #args) do
            local v = args[i]
            if typeof(v) == "Instance" and v:IsA("Player") then return "Server ‚Üí " .. v.Name end
        end
        return "Server ‚Üí " .. LP.Name
    else
        return LP.Name .. " ‚Üí Server"
    end
end

local function generateCode(entry)
    local remote     = entry.remote
    local args       = entry.args
    local remoteType = entry.remoteType
    local direction  = entry.direction or "OUT"
    local method     = (remoteType == "RemoteFunction") and "InvokeServer" or "FireServer"
    local n          = args.n or #args

    local lines = {
        "-- Direction: " .. (direction == "OUT" and "‚Üí Outgoing (client ‚Üí server)" or "‚Üê Incoming (server ‚Üí client)"),
        "local args = {"
    }
    for i = 1, n do
        local comma = (i < n) and "," or ""
        lines[#lines + 1] = string.format("    [%d] = %s%s", i, serialize(args[i], 1, true), comma)
    end
    lines[#lines + 1] = "}"
    lines[#lines + 1] = ""
    lines[#lines + 1] = resolvePath(remote) .. ":" .. method .. "(unpack(args))"

    return table.concat(lines, "\n")
end

local function generateFuncInfoCode(entry)
    local codeStr = generateCode(entry)
    local funcStr = formatFuncInfo(entry.funcInfo)
    return funcStr .. "\n\n" .. codeStr
end

local function dedupeKey(remote, args, direction)
    local ok, j = pcall(function() return HttpService:JSONEncode(args) end)
    return (direction or "?") .. "|" .. remote:GetFullName() .. "|" .. (ok and j or tostring(args))
end

--------------------------------------------------------------------------------
-- MULTI-SELECT
--------------------------------------------------------------------------------
local function addMulti(entry)
    if not spy.multiSel[entry] then
        spy.multiSel[entry] = true
        spy.multiCount = spy.multiCount + 1
    end
end

local function remMulti(entry)
    if spy.multiSel[entry] then
        spy.multiSel[entry] = nil
        spy.multiCount = spy.multiCount - 1
    end
end

local function clearMulti()
    for e in pairs(spy.multiSel) do
        if e.btn and e.btn.Parent then
            e.btn.BackgroundColor3 = (spy.selected == e) and T.ENTRY_SEL or T.ENTRY_IDLE
        end
    end
    spy.multiSel   = {}
    spy.multiCount = 0
end

local function entryColor(e)
    if spy.multiSel[e]    then return T.ENTRY_MULTI end
    if spy.selected == e  then return T.ENTRY_SEL   end
    return T.ENTRY_IDLE
end

--------------------------------------------------------------------------------
-- SCREEN GUI
--------------------------------------------------------------------------------
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name           = "RemoteSpy_v5_2"
ScreenGui.ResetOnSpawn   = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
pcall(function() ScreenGui.IgnoreGuiInset = true end)
ScreenGui.Parent         = LP:WaitForChild("PlayerGui")

--------------------------------------------------------------------------------
-- MAIN WINDOW
--------------------------------------------------------------------------------
local WIN_W, WIN_H = 860, 520

local Main = Instance.new("Frame")
Main.Name             = "Main"
Main.Size             = UDim2.fromOffset(WIN_W, WIN_H)
Main.Position         = UDim2.fromOffset(60, 60)
Main.BackgroundColor3 = T.BG
Main.BorderSizePixel  = 0
Main.Active           = true
Main.Draggable        = true
Main.ClipsDescendants = true
Main.Parent           = ScreenGui
corner(Main, 10)
uiStroke(Main, T.BORDER, 1)

--------------------------------------------------------------------------------
-- TITLE BAR
--------------------------------------------------------------------------------
local TitleBar = Instance.new("Frame")
TitleBar.Name             = "TitleBar"
TitleBar.Size             = UDim2.new(1, 0, 0, 40)
TitleBar.BackgroundColor3 = T.BG2
TitleBar.BorderSizePixel  = 0
TitleBar.ZIndex           = 5
TitleBar.Parent           = Main
corner(TitleBar, 10)

local TBBorder = Instance.new("Frame")
TBBorder.Size             = UDim2.new(1, 0, 0, 1)
TBBorder.Position         = UDim2.new(0, 0, 1, -1)
TBBorder.BackgroundColor3 = T.BORDER
TBBorder.BorderSizePixel  = 0
TBBorder.Parent           = TitleBar

local StatusDot = Instance.new("Frame")
StatusDot.Size             = UDim2.fromOffset(8, 8)
StatusDot.Position         = UDim2.new(0, 14, 0.5, -4)
StatusDot.BackgroundColor3 = T.GREEN
StatusDot.BorderSizePixel  = 0
StatusDot.ZIndex           = 6
StatusDot.Parent           = TitleBar
corner(StatusDot, 4)

local TitleLbl = lbl(TitleBar, "  REMOTE SPY  v" .. VERSION, 13,
    T.TEXT, Enum.Font.GothamBold, Enum.TextXAlignment.Left)
TitleLbl.Size     = UDim2.new(0, 200, 1, 0)
TitleLbl.Position = UDim2.fromOffset(22, 0)
TitleLbl.ZIndex   = 6

local CallsLbl = lbl(TitleBar, "0 calls", 11, T.TEXT_DIM,
    Enum.Font.Gotham, Enum.TextXAlignment.Center)
CallsLbl.Size     = UDim2.fromOffset(90, 40)
CallsLbl.Position = UDim2.new(0, 230, 0, 0)
CallsLbl.ZIndex   = 6

local MultiBadge = Instance.new("Frame")
MultiBadge.Size             = UDim2.fromOffset(22, 16)
MultiBadge.Position         = UDim2.new(0, 325, 0.5, -8)
MultiBadge.BackgroundColor3 = T.BLUE_DIM
MultiBadge.BorderSizePixel  = 0
MultiBadge.Visible          = false
MultiBadge.ZIndex           = 6
MultiBadge.Parent           = TitleBar
corner(MultiBadge, 8)
local MultiBadgeLbl = lbl(MultiBadge, "0", 9, Color3.new(1,1,1),
    Enum.Font.GothamBold, Enum.TextXAlignment.Center)
MultiBadgeLbl.Size   = UDim2.new(1,0,1,0)
MultiBadgeLbl.ZIndex = 7

local PausedBadge = Instance.new("Frame")
PausedBadge.Size             = UDim2.fromOffset(54, 18)
PausedBadge.Position         = UDim2.new(0, 355, 0.5, -9)
PausedBadge.BackgroundColor3 = T.ORANGE
PausedBadge.BorderSizePixel  = 0
PausedBadge.Visible          = false
PausedBadge.ZIndex           = 6
PausedBadge.Parent           = TitleBar
corner(PausedBadge, 4)
local PausedLbl = lbl(PausedBadge, "PAUSED", 9, Color3.new(1,1,1),
    Enum.Font.GothamBold, Enum.TextXAlignment.Center)
PausedLbl.Size   = UDim2.new(1,0,1,0)
PausedLbl.ZIndex = 7

local function mkIconBtn(xOff, icon)
    local b = Instance.new("TextButton")
    b.Size             = UDim2.fromOffset(28, 28)
    b.Position         = UDim2.new(1, xOff, 0.5, -14)
    b.BackgroundColor3 = T.BG3
    b.Text             = icon
    b.TextColor3       = T.TEXT_DIM
    b.Font             = Enum.Font.GothamBold
    b.TextSize         = 14
    b.AutoButtonColor  = false
    b.ZIndex           = 6
    b.Parent           = TitleBar
    corner(b, 6)
    hoverBtn(b, T.BG4, T.BG3)
    return b
end

local MinBtn   = mkIconBtn(-36, "‚îÄ")
local PauseBtn = mkIconBtn(-70, "‚è∏")

local SearchFrame = Instance.new("Frame")
SearchFrame.Size             = UDim2.fromOffset(160, 24)
SearchFrame.Position         = UDim2.new(1, -240, 0.5, -12)
SearchFrame.BackgroundColor3 = T.BG3
SearchFrame.BorderSizePixel  = 0
SearchFrame.ZIndex           = 6
SearchFrame.Parent           = TitleBar
corner(SearchFrame, 5)
uiStroke(SearchFrame, T.BORDER2, 1)

local SearchIcon = lbl(SearchFrame, "üîç", 11, T.TEXT_MUTED, Enum.Font.Gotham, Enum.TextXAlignment.Center)
SearchIcon.Size     = UDim2.fromOffset(22, 24)
SearchIcon.Position = UDim2.fromOffset(2, 0)
SearchIcon.ZIndex   = 7

local SearchBox = Instance.new("TextBox")
SearchBox.Size              = UDim2.new(1, -26, 1, 0)
SearchBox.Position          = UDim2.fromOffset(24, 0)
SearchBox.BackgroundTransparency = 1
SearchBox.Text              = ""
SearchBox.PlaceholderText   = "Filter remotes‚Ä¶"
SearchBox.PlaceholderColor3 = T.TEXT_MUTED
SearchBox.TextColor3        = T.TEXT
SearchBox.Font              = Enum.Font.Gotham
SearchBox.TextSize          = 11
SearchBox.ClearTextOnFocus  = false
SearchBox.TextXAlignment    = Enum.TextXAlignment.Left
SearchBox.ZIndex            = 7
SearchBox.Parent            = SearchFrame

--------------------------------------------------------------------------------
-- TAB BAR
--------------------------------------------------------------------------------
local TabBar = Instance.new("Frame")
TabBar.Size             = UDim2.new(1, 0, 0, 30)
TabBar.Position         = UDim2.fromOffset(0, 40)
TabBar.BackgroundColor3 = T.BG2
TabBar.BorderSizePixel  = 0
TabBar.Parent           = Main

local TabBorder = Instance.new("Frame")
TabBorder.Size             = UDim2.new(1, 0, 0, 1)
TabBorder.Position         = UDim2.new(0, 0, 1, -1)
TabBorder.BackgroundColor3 = T.BORDER
TabBorder.BorderSizePixel  = 0
TabBorder.Parent           = TabBar

local function mkTab(txt, xOff, w)
    w = w or 110
    local f = Instance.new("Frame")
    f.Size             = UDim2.fromOffset(w, 30)
    f.Position         = UDim2.fromOffset(xOff, 0)
    f.BackgroundTransparency = 1
    f.Parent           = TabBar
    local b = Instance.new("TextButton")
    b.Size             = UDim2.new(1, 0, 1, 0)
    b.BackgroundTransparency = 1
    b.Text             = txt
    b.TextColor3       = T.TEXT_DIM
    b.Font             = Enum.Font.GothamSemibold
    b.TextSize         = 12
    b.AutoButtonColor  = false
    b.Parent           = f
    local indicator = Instance.new("Frame")
    indicator.Size             = UDim2.new(0.7, 0, 0, 2)
    indicator.Position         = UDim2.new(0.15, 0, 1, -2)
    indicator.BackgroundColor3 = T.GREEN
    indicator.BorderSizePixel  = 0
    indicator.Visible          = false
    indicator.Parent           = f
    corner(indicator, 1)
    return b, indicator
end

local TabLog,     TabLogInd     = mkTab("  REMOTE LOG",   4,   120)
local TabExecLog, TabExecLogInd = mkTab("  EXEC LOG",     128, 100)

-- Direction filter
local DirFilterFrame = Instance.new("Frame")
DirFilterFrame.Size             = UDim2.fromOffset(200, 24)
DirFilterFrame.Position         = UDim2.new(1, -208, 0.5, -12)
DirFilterFrame.BackgroundTransparency = 1
DirFilterFrame.Parent           = TabBar

local function mkDirBtn(txt, xOff, w)
    local b = Instance.new("TextButton")
    b.Size             = UDim2.fromOffset(w or 60, 20)
    b.Position         = UDim2.fromOffset(xOff, 2)
    b.BackgroundColor3 = T.BG3
    b.Text             = txt
    b.TextColor3       = T.TEXT_DIM
    b.Font             = Enum.Font.GothamBold
    b.TextSize         = 10
    b.AutoButtonColor  = false
    b.Parent           = DirFilterFrame
    corner(b, 4)
    uiStroke(b, T.BORDER, 1)
    return b
end

local DirAllBtn = mkDirBtn("ALL",    0,   44)
local DirOutBtn = mkDirBtn("‚Üí OUT", 48,   54)
local DirInBtn  = mkDirBtn("‚Üê IN", 106,  50)

local function updateDirBtns()
    DirAllBtn.BackgroundColor3 = spy.dirFilter == "all" and T.BG4 or T.BG3
    DirAllBtn.TextColor3       = spy.dirFilter == "all" and T.TEXT or T.TEXT_DIM
    DirOutBtn.BackgroundColor3 = spy.dirFilter == "out" and T.DIR_OUT or T.BG3
    DirOutBtn.TextColor3       = spy.dirFilter == "out" and Color3.new(1,1,1) or T.TEXT_DIM
    DirInBtn.BackgroundColor3  = spy.dirFilter == "in"  and T.DIR_IN  or T.BG3
    DirInBtn.TextColor3        = spy.dirFilter == "in"  and Color3.new(1,1,1) or T.TEXT_DIM
end
updateDirBtns()

--------------------------------------------------------------------------------
-- BODY
--------------------------------------------------------------------------------
local Body = Instance.new("Frame")
Body.Name             = "Body"
Body.Size             = UDim2.new(1, 0, 1, -71)
Body.Position         = UDim2.fromOffset(0, 71)
Body.BackgroundTransparency = 1
Body.ClipsDescendants = false
Body.Parent           = Main

--------------------------------------------------------------------------------
-- LOG PANEL (left)
--------------------------------------------------------------------------------
local logPanelW = 430

local LogPanel = Instance.new("Frame")
LogPanel.Name             = "LogPanel"
LogPanel.Size             = UDim2.new(0, logPanelW, 1, 0)
LogPanel.BackgroundTransparency = 1
LogPanel.ClipsDescendants = true
LogPanel.Parent           = Body

local LogFrame = Instance.new("ScrollingFrame")
LogFrame.Name                 = "LogFrame"
LogFrame.Size                 = UDim2.new(1, -8, 1, -8)
LogFrame.Position             = UDim2.fromOffset(4, 4)
LogFrame.BackgroundColor3     = T.BG2
LogFrame.ScrollBarThickness   = 4
LogFrame.ScrollBarImageColor3 = T.BORDER2
LogFrame.BorderSizePixel      = 0
LogFrame.CanvasSize           = UDim2.new(0, 0, 0, 0)
LogFrame.Parent               = LogPanel
corner(LogFrame, 6)
uiStroke(LogFrame, T.BORDER, 1)

local LogLayout = Instance.new("UIListLayout")
LogLayout.Padding         = UDim.new(0, 2)
LogLayout.SortOrder       = Enum.SortOrder.LayoutOrder
LogLayout.Parent          = LogFrame

local LogPad = Instance.new("UIPadding")
LogPad.PaddingTop    = UDim.new(0, 4)
LogPad.PaddingBottom = UDim.new(0, 4)
LogPad.PaddingLeft   = UDim.new(0, 4)
LogPad.PaddingRight  = UDim.new(0, 4)
LogPad.Parent        = LogFrame

local ExecLogFrame = Instance.new("ScrollingFrame")
ExecLogFrame.Name                 = "ExecLogFrame"
ExecLogFrame.Size                 = UDim2.new(1, -8, 1, -8)
ExecLogFrame.Position             = UDim2.fromOffset(4, 4)
ExecLogFrame.BackgroundColor3     = T.BG2
ExecLogFrame.ScrollBarThickness   = 4
ExecLogFrame.ScrollBarImageColor3 = T.BORDER2
ExecLogFrame.BorderSizePixel      = 0
ExecLogFrame.Visible              = false
ExecLogFrame.CanvasSize           = UDim2.new(0, 0, 0, 0)
ExecLogFrame.Parent               = LogPanel
corner(ExecLogFrame, 6)
uiStroke(ExecLogFrame, T.BORDER, 1)

local ExecLogLayout = Instance.new("UIListLayout")
ExecLogLayout.Padding   = UDim.new(0, 2)
ExecLogLayout.SortOrder = Enum.SortOrder.LayoutOrder
ExecLogLayout.Parent    = ExecLogFrame

local ExecLogPad = Instance.new("UIPadding")
ExecLogPad.PaddingTop    = UDim.new(0, 4)
ExecLogPad.PaddingBottom = UDim.new(0, 4)
ExecLogPad.PaddingLeft   = UDim.new(0, 4)
ExecLogPad.PaddingRight  = UDim.new(0, 4)
ExecLogPad.Parent        = ExecLogFrame

--------------------------------------------------------------------------------
-- DIVIDER
--------------------------------------------------------------------------------
local Divider = Instance.new("Frame")
Divider.Name             = "Divider"
Divider.Size             = UDim2.new(0, 5, 1, 0)
Divider.Position         = UDim2.fromOffset(logPanelW, 0)
Divider.BackgroundColor3 = T.BORDER
Divider.BorderSizePixel  = 0
Divider.Parent           = Body

local DivHandle = Instance.new("TextButton")
DivHandle.Size             = UDim2.new(1, 4, 1, 0)
DivHandle.Position         = UDim2.fromOffset(-2, 0)
DivHandle.BackgroundTransparency = 1
DivHandle.Text             = ""
DivHandle.AutoButtonColor  = false
DivHandle.Parent           = Divider

--------------------------------------------------------------------------------
-- CONTROL PANEL (right)
--------------------------------------------------------------------------------
local CtrlPanel = Instance.new("Frame")
CtrlPanel.Name             = "CtrlPanel"
CtrlPanel.Size             = UDim2.new(1, -(logPanelW + 5), 1, 0)
CtrlPanel.Position         = UDim2.fromOffset(logPanelW + 5, 0)
CtrlPanel.BackgroundTransparency = 1
CtrlPanel.ClipsDescendants = true
CtrlPanel.Parent           = Body

-- Code header
local CodeHeader = Instance.new("Frame")
CodeHeader.Size             = UDim2.new(1, -8, 0, 22)
CodeHeader.Position         = UDim2.fromOffset(4, 4)
CodeHeader.BackgroundColor3 = T.BG3
CodeHeader.BorderSizePixel  = 0
CodeHeader.Parent           = CtrlPanel
corner(CodeHeader, 4)

local CodeHdrLbl = lbl(CodeHeader, "  CODE PREVIEW / EDIT", 10, T.TEXT_MUTED, Enum.Font.GothamBold)
CodeHdrLbl.Size = UDim2.new(0.6, 0, 1, 0)

local CodeLangLbl = lbl(CodeHeader, "Lua  ", 10, T.TEXT_MUTED, Enum.Font.Code, Enum.TextXAlignment.Right)
CodeLangLbl.Size = UDim2.new(0.4, 0, 1, 0)

local CodeBox = Instance.new("TextBox")
CodeBox.Size              = UDim2.new(1, -8, 0, 140)
CodeBox.Position          = UDim2.fromOffset(4, 28)
CodeBox.BackgroundColor3  = T.BG
CodeBox.TextColor3        = T.CODE
CodeBox.PlaceholderColor3 = T.TEXT_MUTED
CodeBox.PlaceholderText   = "-- Click a log entry to generate code --"
CodeBox.Font              = Enum.Font.Code
CodeBox.TextSize          = 11
CodeBox.TextXAlignment    = Enum.TextXAlignment.Left
CodeBox.TextYAlignment    = Enum.TextYAlignment.Top
CodeBox.ClearTextOnFocus  = false
CodeBox.MultiLine         = true
CodeBox.TextWrapped       = true
CodeBox.Text              = ""
CodeBox.Parent            = CtrlPanel
corner(CodeBox, 4)
uiStroke(CodeBox, T.BORDER, 1)

--------------------------------------------------------------------------------
-- FUNCTION INFO PANEL
--------------------------------------------------------------------------------
local FuncInfoHeader = Instance.new("Frame")
FuncInfoHeader.Size             = UDim2.new(1, -8, 0, 20)
FuncInfoHeader.Position         = UDim2.fromOffset(4, 170)
FuncInfoHeader.BackgroundColor3 = T.FUNC_HDR
FuncInfoHeader.BorderSizePixel  = 0
FuncInfoHeader.Parent           = CtrlPanel
corner(FuncInfoHeader, 4)

local FuncInfoTitleLbl = lbl(FuncInfoHeader, "  ∆í  FUNCTION INFO", 10, Color3.new(1,1,1), Enum.Font.GothamBold)
FuncInfoTitleLbl.Size = UDim2.new(0.7, 0, 1, 0)

-- small badge showing if info was captured
local FuncInfoBadge = Instance.new("Frame")
FuncInfoBadge.Size             = UDim2.fromOffset(46, 14)
FuncInfoBadge.Position         = UDim2.new(1, -52, 0.5, -7)
FuncInfoBadge.BackgroundColor3 = T.BG4
FuncInfoBadge.BorderSizePixel  = 0
FuncInfoBadge.Parent           = FuncInfoHeader
corner(FuncInfoBadge, 6)
local FuncInfoBadgeLbl = lbl(FuncInfoBadge, "NONE", 8, T.TEXT_MUTED, Enum.Font.GothamBold, Enum.TextXAlignment.Center)
FuncInfoBadgeLbl.Size = UDim2.new(1,0,1,0)

local FuncInfoBox = Instance.new("TextBox")
FuncInfoBox.Size              = UDim2.new(1, -8, 0, 88)
FuncInfoBox.Position          = UDim2.fromOffset(4, 192)
FuncInfoBox.BackgroundColor3  = Color3.fromRGB(16, 10, 28)
FuncInfoBox.TextColor3        = Color3.fromRGB(180, 140, 255)
FuncInfoBox.PlaceholderColor3 = T.TEXT_MUTED
FuncInfoBox.PlaceholderText   = "-- Select a remote entry to see caller info --"
FuncInfoBox.Font              = Enum.Font.Code
FuncInfoBox.TextSize          = 10
FuncInfoBox.TextXAlignment    = Enum.TextXAlignment.Left
FuncInfoBox.TextYAlignment    = Enum.TextYAlignment.Top
FuncInfoBox.ClearTextOnFocus  = false
FuncInfoBox.MultiLine         = true
FuncInfoBox.TextWrapped       = true
FuncInfoBox.Text              = ""
FuncInfoBox.Parent            = CtrlPanel
corner(FuncInfoBox, 4)
uiStroke(FuncInfoBox, Color3.fromRGB(70, 40, 110), 1)

-- Status bar
local StatusBar = Instance.new("Frame")
StatusBar.Size             = UDim2.new(1, -8, 0, 20)
StatusBar.Position         = UDim2.fromOffset(4, 284)
StatusBar.BackgroundColor3 = T.BG2
StatusBar.BorderSizePixel  = 0
StatusBar.Parent           = CtrlPanel
corner(StatusBar, 3)

local StatusLbl = lbl(StatusBar, "", 10, T.TEXT_DIM, Enum.Font.Code)
StatusLbl.Size        = UDim2.new(1, -8, 1, 0)
StatusLbl.Position    = UDim2.fromOffset(6, 0)
StatusLbl.TextWrapped = false

local function setStatus(txt, col)
    StatusLbl.Text       = txt
    StatusLbl.TextColor3 = col or T.TEXT_DIM
end

--------------------------------------------------------------------------------
-- REPEAT FIRE ROW
--------------------------------------------------------------------------------
local RepeatRow = Instance.new("Frame")
RepeatRow.Size             = UDim2.new(1, -8, 0, 26)
RepeatRow.Position         = UDim2.fromOffset(4, 308)
RepeatRow.BackgroundColor3 = T.BG2
RepeatRow.BorderSizePixel  = 0
RepeatRow.Parent           = CtrlPanel
corner(RepeatRow, 4)

local RepeatLbl = lbl(RepeatRow, "  Repeat:", 10, T.TEXT_DIM, Enum.Font.Gotham)
RepeatLbl.Size     = UDim2.fromOffset(60, 26)

local RepeatBox = Instance.new("TextBox")
RepeatBox.Size             = UDim2.fromOffset(36, 18)
RepeatBox.Position         = UDim2.fromOffset(62, 4)
RepeatBox.BackgroundColor3 = T.BG3
RepeatBox.TextColor3       = T.TEXT
RepeatBox.Font             = Enum.Font.Code
RepeatBox.TextSize         = 11
RepeatBox.Text             = "1"
RepeatBox.TextXAlignment   = Enum.TextXAlignment.Center
RepeatBox.Parent           = RepeatRow
corner(RepeatBox, 3)
uiStroke(RepeatBox, T.BORDER, 1)

local IntervalLbl = lbl(RepeatRow, "  Interval (s):", 10, T.TEXT_DIM, Enum.Font.Gotham)
IntervalLbl.Size     = UDim2.fromOffset(80, 26)
IntervalLbl.Position = UDim2.fromOffset(100, 0)

local IntervalBox = Instance.new("TextBox")
IntervalBox.Size             = UDim2.fromOffset(40, 18)
IntervalBox.Position         = UDim2.fromOffset(184, 4)
IntervalBox.BackgroundColor3 = T.BG3
IntervalBox.TextColor3       = T.TEXT
IntervalBox.Font             = Enum.Font.Code
IntervalBox.TextSize         = 11
IntervalBox.Text             = "0"
IntervalBox.TextXAlignment   = Enum.TextXAlignment.Center
IntervalBox.Parent           = RepeatRow
corner(IntervalBox, 3)
uiStroke(IntervalBox, T.BORDER, 1)

local LoopToggle = Instance.new("TextButton")
LoopToggle.Size             = UDim2.fromOffset(50, 18)
LoopToggle.Position         = UDim2.fromOffset(228, 4)
LoopToggle.BackgroundColor3 = T.BG3
LoopToggle.Text             = "LOOP"
LoopToggle.TextColor3       = T.TEXT_DIM
LoopToggle.Font             = Enum.Font.GothamBold
LoopToggle.TextSize         = 9
LoopToggle.AutoButtonColor  = false
LoopToggle.Parent           = RepeatRow
corner(LoopToggle, 3)
uiStroke(LoopToggle, T.BORDER, 1)

local MultiDelayLbl = lbl(RepeatRow, "  Multi Œî:", 10, T.TEXT_DIM, Enum.Font.Gotham)
MultiDelayLbl.Size     = UDim2.fromOffset(58, 26)
MultiDelayLbl.Position = UDim2.fromOffset(282, 0)

local MultiDelayBox = Instance.new("TextBox")
MultiDelayBox.Size             = UDim2.fromOffset(34, 18)
MultiDelayBox.Position         = UDim2.fromOffset(340, 4)
MultiDelayBox.BackgroundColor3 = T.BG3
MultiDelayBox.TextColor3       = T.TEXT
MultiDelayBox.Font             = Enum.Font.Code
MultiDelayBox.TextSize         = 11
MultiDelayBox.Text             = "0"
MultiDelayBox.TextXAlignment   = Enum.TextXAlignment.Center
MultiDelayBox.Parent           = RepeatRow
corner(MultiDelayBox, 3)
uiStroke(MultiDelayBox, T.BORDER, 1)

--------------------------------------------------------------------------------
-- ACTION BUTTONS
--------------------------------------------------------------------------------
local BtnGrid = Instance.new("Frame")
BtnGrid.Size             = UDim2.new(1, -8, 0, 110)
BtnGrid.Position         = UDim2.fromOffset(4, 338)
BtnGrid.BackgroundTransparency = 1
BtnGrid.Parent           = CtrlPanel

local BtnLayout = Instance.new("UIGridLayout")
BtnLayout.CellSize         = UDim2.new(0.5, -3, 0, 30)
BtnLayout.CellPadding      = UDim2.fromOffset(4, 4)
BtnLayout.SortOrder        = Enum.SortOrder.LayoutOrder
BtnLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
BtnLayout.Parent           = BtnGrid

local function actionBtn(txt, bgCol, order)
    local b = Instance.new("TextButton")
    b.BackgroundColor3 = bgCol
    b.Text             = txt
    b.TextColor3       = Color3.new(1,1,1)
    b.Font             = Enum.Font.GothamBold
    b.TextSize         = 11
    b.AutoButtonColor  = false
    b.LayoutOrder      = order or 0
    b.Parent           = BtnGrid
    corner(b, 5)
    hoverBtn(b, Color3.new(
        math.min(bgCol.R + 0.1, 1),
        math.min(bgCol.G + 0.1, 1),
        math.min(bgCol.B + 0.1, 1)), bgCol)
    return b
end

local FireBtn     = actionBtn("‚ñ∂  FIRE SELECTED",    T.GREEN_DIM,                   1)
local FireAllBtn  = actionBtn("‚ö°  FIRE ALL (0)",     T.BLUE_DIM,                    2)
local CopyBtn     = actionBtn("‚éò  COPY CODE",        Color3.fromRGB(40, 80, 160),   3)
local CopyFuncBtn = actionBtn("∆í  COPY FUNC INFO",   Color3.fromRGB(80, 40, 140),   4)
local BlockBtn    = actionBtn("‚äò  BLOCK REMOTE",     Color3.fromRGB(150, 95, 15),   5)
local DeselectBtn = actionBtn("‚òê  DESELECT ALL",     Color3.fromRGB(55, 55, 75),    6)
local ClearBtn    = actionBtn("‚úï  CLEAR LOGS",       Color3.fromRGB(140, 35, 35),   7)

--------------------------------------------------------------------------------
-- HELPERS: COUNTS / BADGES
--------------------------------------------------------------------------------
local function updateCountLbl()
    CallsLbl.Text = spy.totalCalls .. " call" .. (spy.totalCalls ~= 1 and "s" or "")
end

local function updateMultiBadge()
    if spy.multiCount > 0 then
        MultiBadge.Visible    = true
        MultiBadgeLbl.Text    = tostring(spy.multiCount)
        FireAllBtn.Text       = "‚ö°  FIRE ALL (" .. spy.multiCount .. ")"
    else
        MultiBadge.Visible    = false
        FireAllBtn.Text       = "‚ö°  FIRE ALL (0)"
    end
end

-- LAG FIX: debounced canvas update
local canvasUpdateScheduled = false
local function updateCanvas()
    if canvasUpdateScheduled then return end
    canvasUpdateScheduled = true
    task.delay(CANVAS_DEBOUNCE, function()
        canvasUpdateScheduled = false
        LogFrame.CanvasSize = UDim2.new(0, 0, 0, LogLayout.AbsoluteContentSize.Y + 8)
        local c = LogFrame.AbsoluteCanvasSize.Y
        local w = LogFrame.AbsoluteWindowSize.Y
        if c - LogFrame.CanvasPosition.Y - w < SCROLL_THRESH then
            LogFrame.CanvasPosition = Vector2.new(0, math.huge)
        end
    end)
end

local function entryVisible(entry)
    if spy.filterText ~= "" then
        if not entry.remote.Name:lower():find(spy.filterText:lower(), 1, true) then
            return false
        end
    end
    if spy.dirFilter ~= "all" then
        if entry.direction ~= spy.dirFilter:upper() then
            return false
        end
    end
    return true
end

local function refreshFilter()
    for _, entry in ipairs(spy.entries) do
        if entry.btn and entry.btn.Parent then
            entry.btn.Visible = entryVisible(entry)
        end
    end
    updateCanvas()
end

-- Update the Function Info panel when an entry is selected
local function showFuncInfo(entry)
    if not entry then
        FuncInfoBox.Text      = ""
        FuncInfoBadgeLbl.Text = "NONE"
        FuncInfoBadge.BackgroundColor3 = T.BG4
        FuncInfoBadgeLbl.TextColor3    = T.TEXT_MUTED
        return
    end
    local fi = entry.funcInfo
    if fi and (fi.name or fi.source or fi.line) then
        FuncInfoBox.Text      = formatFuncInfo(fi)
        FuncInfoBadgeLbl.Text = "FOUND"
        FuncInfoBadge.BackgroundColor3 = T.GREEN_DIM
        FuncInfoBadgeLbl.TextColor3    = Color3.new(1,1,1)
    else
        FuncInfoBox.Text      = "-- Function info not available.\n-- Executor may not support debug.info\n-- or this was an incoming (server‚Üíclient) event."
        FuncInfoBadgeLbl.Text = "N/A"
        FuncInfoBadge.BackgroundColor3 = T.BG4
        FuncInfoBadgeLbl.TextColor3    = T.TEXT_MUTED
    end
end

--------------------------------------------------------------------------------
-- BUILD LOG ENTRY (single row)
--------------------------------------------------------------------------------
local function buildLogEntry(remote, args, remoteType, direction, funcInfo)
    direction = direction or "OUT"
    local caller    = getCallerName(remoteType, direction, args)
    local preview   = argPreview(args)
    local timestamp = os.date("%H:%M:%S")

    local entry = {
        remote     = remote,
        args       = args,
        remoteType = remoteType,
        direction  = direction,
        caller     = caller,
        funcInfo   = funcInfo,
        count      = 1,
        lastTime   = os.clock(),
        timestamp  = timestamp,
        listIndex  = #spy.entries + 1,
    }

    local btn_h = Instance.new("TextButton")
    btn_h.Name             = "Entry_" .. remote.Name
    btn_h.Size             = UDim2.new(1, 0, 0, 46)
    btn_h.BackgroundColor3 = T.ENTRY_IDLE
    btn_h.Text             = ""
    btn_h.AutoButtonColor  = false
    btn_h.LayoutOrder      = entry.listIndex
    btn_h.Visible          = entryVisible(entry)
    btn_h.Parent           = LogFrame
    corner(btn_h, 4)

    -- Direction bar
    local dirBar = Instance.new("Frame")
    dirBar.Size             = UDim2.fromOffset(3, 34)
    dirBar.Position         = UDim2.fromOffset(4, 6)
    dirBar.BackgroundColor3 = direction == "OUT" and T.DIR_OUT or T.DIR_IN
    dirBar.BorderSizePixel  = 0
    dirBar.Parent           = btn_h
    corner(dirBar, 2)

    local dirArrow = lbl(btn_h,
        direction == "OUT" and "‚Üí" or "‚Üê",
        11,
        direction == "OUT" and T.DIR_OUT or T.DIR_IN,
        Enum.Font.GothamBold, Enum.TextXAlignment.Center)
    dirArrow.Size     = UDim2.fromOffset(14, 14)
    dirArrow.Position = UDim2.fromOffset(9, 6)

    -- RE / RF badge
    local typeBadge = Instance.new("Frame")
    typeBadge.Size             = UDim2.fromOffset(24, 14)
    typeBadge.Position         = UDim2.fromOffset(10, 25)
    typeBadge.BackgroundColor3 = remoteType == "RemoteFunction" and T.RF_CLR or T.RE_CLR
    typeBadge.BorderSizePixel  = 0
    typeBadge.Parent           = btn_h
    corner(typeBadge, 3)
    local typeTxt = lbl(typeBadge,
        remoteType == "RemoteFunction" and "RF" or "RE",
        8, Color3.new(1,1,1), Enum.Font.GothamBold, Enum.TextXAlignment.Center)
    typeTxt.Size = UDim2.new(1,0,1,0)

    -- ∆í badge if func info captured
    if funcInfo and (funcInfo.name or funcInfo.source) then
        local fiBadge = Instance.new("Frame")
        fiBadge.Size             = UDim2.fromOffset(14, 14)
        fiBadge.Position         = UDim2.fromOffset(36, 25)
        fiBadge.BackgroundColor3 = T.FUNC_HDR
        fiBadge.BorderSizePixel  = 0
        fiBadge.Parent           = btn_h
        corner(fiBadge, 3)
        local fiTxt = lbl(fiBadge, "∆í", 8, Color3.new(1,1,1), Enum.Font.GothamBold, Enum.TextXAlignment.Center)
        fiTxt.Size = UDim2.new(1,0,1,0)
    end

    local nameLbl2 = lbl(btn_h, remote.Name, 13, T.TEXT, Enum.Font.GothamSemibold)
    nameLbl2.Size     = UDim2.new(1, -110, 0, 18)
    nameLbl2.Position = UDim2.fromOffset(38, 5)

    local previewLbl = lbl(btn_h, preview, 10, T.TEXT_MUTED, Enum.Font.Code)
    previewLbl.Size     = UDim2.new(1, -110, 0, 14)
    previewLbl.Position = UDim2.fromOffset(38, 25)
    previewLbl.TextWrapped = false

    local tsLbl = lbl(btn_h, timestamp, 9, T.TEXT_MUTED, Enum.Font.Code, Enum.TextXAlignment.Right)
    tsLbl.Size     = UDim2.fromOffset(56, 14)
    tsLbl.Position = UDim2.new(1, -62, 0, 6)

    local cntWrap = Instance.new("Frame")
    cntWrap.Size             = UDim2.fromOffset(28, 14)
    cntWrap.Position         = UDim2.new(1, -62, 0, 22)
    cntWrap.BackgroundColor3 = T.BG4
    cntWrap.BorderSizePixel  = 0
    cntWrap.Visible          = false
    cntWrap.Parent           = btn_h
    corner(cntWrap, 7)
    local cntLbl2 = lbl(cntWrap, "√ó1", 8, T.TEXT_DIM, Enum.Font.GothamBold, Enum.TextXAlignment.Center)
    cntLbl2.Size = UDim2.new(1,0,1,0)

    entry.btn        = btn_h
    entry.cntWrap    = cntWrap
    entry.cntLbl     = cntLbl2
    entry.previewLbl = previewLbl

    -- ‚îÄ‚îÄ CLICK HANDLERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    btn_h.MouseButton1Click:Connect(function()
        local ctrl  = UserInputService:IsKeyDown(Enum.KeyCode.LeftControl)
                   or UserInputService:IsKeyDown(Enum.KeyCode.RightControl)
        local shift = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift)
                   or UserInputService:IsKeyDown(Enum.KeyCode.RightShift)

        if ctrl then
            if spy.multiSel[entry] then
                remMulti(entry)
                btn_h.BackgroundColor3 = (spy.selected == entry) and T.ENTRY_SEL or T.ENTRY_IDLE
            else
                addMulti(entry)
                btn_h.BackgroundColor3 = T.ENTRY_MULTI
            end
            updateMultiBadge()
            setStatus("‚ö° " .. spy.multiCount .. " selected  |  Ctrl+Click to toggle", T.BLUE)

        elseif shift and spy.lastClickIdx then
            local a  = math.min(spy.lastClickIdx, entry.listIndex)
            local b2 = math.max(spy.lastClickIdx, entry.listIndex)
            for _, e in ipairs(spy.entries) do
                if e.listIndex >= a and e.listIndex <= b2 then
                    addMulti(e)
                    if e.btn and e.btn.Parent then
                        e.btn.BackgroundColor3 = T.ENTRY_MULTI
                    end
                end
            end
            updateMultiBadge()
            setStatus("‚ö° Range selected " .. spy.multiCount .. " entries", T.BLUE)

        else
            if spy.selected and spy.selected.btn and spy.selected.btn.Parent then
                spy.selected.btn.BackgroundColor3 = entryColor(spy.selected)
            end
            spy.selected     = entry
            spy.lastClickIdx = entry.listIndex
            btn_h.BackgroundColor3 = spy.multiSel[entry] and T.ENTRY_MULTI or T.ENTRY_SEL
            CodeBox.Text     = generateCode(entry)
            showFuncInfo(entry)
            BlockBtn.Text    = "‚äò  BLOCK: " .. remote.Name
            local dirNote = direction == "OUT" and "‚Üí Outgoing" or "‚Üê Incoming"
            setStatus(dirNote .. "  |  " .. caller, direction == "OUT" and T.DIR_OUT or T.DIR_IN)
        end
    end)

    -- Right-click = instant block
    btn_h.MouseButton2Click:Connect(function()
        remMulti(entry)
        updateMultiBadge()
        spy.blocked[remote.Name] = true
        if spy.selected == entry then
            spy.selected = nil
            CodeBox.Text = ""
            showFuncInfo(nil)
        end
        btn_h:Destroy()
        for i, e in ipairs(spy.entries) do
            if e == entry then table.remove(spy.entries, i) break end
        end
        spy.entryMap[dedupeKey(remote, args, direction)] = nil
        setStatus("‚äò Blocked: " .. remote.Name, T.ORANGE)
    end)

    btn_h.MouseEnter:Connect(function()
        if entryColor(entry) == T.ENTRY_IDLE then
            btn_h.BackgroundColor3 = T.ENTRY_HOVER
        end
    end)
    btn_h.MouseLeave:Connect(function()
        btn_h.BackgroundColor3 = entryColor(entry)
    end)

    return entry
end

--------------------------------------------------------------------------------
-- ADD LOG  (called from hook ‚Äî LAG FIX: queued, processed per frame)
--------------------------------------------------------------------------------
local function addLogImmediate(remote, args, remoteType, direction, funcInfo)
    if spy.paused               then return end
    if spy.blocked[remote.Name] then return end

    direction = direction or "OUT"
    spy.totalCalls = spy.totalCalls + 1
    updateCountLbl()

    spy.histIdx = (spy.histIdx % MAX_HISTORY) + 1
    spy.history[spy.histIdx] = {
        remote = remote, args = args, rtype = remoteType,
        dir = direction, t = os.clock()
    }

    local key = dedupeKey(remote, args, direction)
    local now = os.clock()
    local ex  = spy.entryMap[key]

    if ex and (now - ex.lastTime) < DEDUPE_WINDOW and ex.btn and ex.btn.Parent then
        ex.count    = ex.count + 1
        ex.lastTime = now
        ex.args     = args
        -- LAG FIX: only flash color, no tween on every dedup hit
        ex.btn.BackgroundColor3 = Color3.fromRGB(25, 55, 30)
        task.delay(0.12, function()
            if ex.btn and ex.btn.Parent then
                ex.btn.BackgroundColor3 = entryColor(ex)
            end
        end)
        ex.cntWrap.Visible = true
        ex.cntLbl.Text     = "√ó" .. ex.count
        if ex.previewLbl then
            ex.previewLbl.Text = argPreview(args)
        end
        return
    end

    -- LAG FIX: trim oldest entry if over cap
    if #spy.entries >= MAX_LOG_ENTRIES then
        local oldest = spy.entries[1]
        if oldest.btn and oldest.btn.Parent then
            oldest.btn:Destroy()
        end
        table.remove(spy.entries, 1)
        local oldKey = dedupeKey(oldest.remote, oldest.args, oldest.direction)
        spy.entryMap[oldKey] = nil
    end

    local entry = buildLogEntry(remote, args, remoteType, direction, funcInfo)
    table.insert(spy.entries, entry)
    spy.entryMap[key] = entry
    updateCanvas()
end

-- LAG FIX: hooks write to queue; frame loop drains at most 5 per frame
local function addLog(remote, args, remoteType, direction, funcInfo)
    table.insert(pendingLogs, {remote, args, remoteType, direction, funcInfo})
end

RunService.Heartbeat:Connect(function()
    -- drain up to 5 pending logs per frame to avoid frame spikes
    local limit = math.min(5, #pendingLogs)
    for i = 1, limit do
        local p = table.remove(pendingLogs, 1)
        if p then
            pcall(addLogImmediate, p[1], p[2], p[3], p[4], p[5])
        end
    end
end)

--------------------------------------------------------------------------------
-- DIRECTION FILTER
--------------------------------------------------------------------------------
local function setDirFilter(f)
    spy.dirFilter = f
    updateDirBtns()
    refreshFilter()
end

DirAllBtn.MouseButton1Click:Connect(function() setDirFilter("all") end)
DirOutBtn.MouseButton1Click:Connect(function() setDirFilter("out") end)
DirInBtn.MouseButton1Click:Connect(function()  setDirFilter("in")  end)

--------------------------------------------------------------------------------
-- TAB SWITCHING
--------------------------------------------------------------------------------
local function setTab(tab)
    spy.activeTab = tab
    LogFrame.Visible      = (tab == "log")
    ExecLogFrame.Visible  = (tab == "execlog")
    TabLogInd.Visible     = (tab == "log")
    TabExecLogInd.Visible = (tab == "execlog")
    TabLog.TextColor3     = (tab == "log")     and T.TEXT or T.TEXT_DIM
    TabExecLog.TextColor3 = (tab == "execlog") and T.TEXT or T.TEXT_DIM
end

setTab("log")
TabLog.MouseButton1Click:Connect(function()     setTab("log")     end)
TabExecLog.MouseButton1Click:Connect(function() setTab("execlog") end)

--------------------------------------------------------------------------------
-- SEARCH
--------------------------------------------------------------------------------
SearchBox:GetPropertyChangedSignal("Text"):Connect(function()
    spy.filterText = SearchBox.Text
    refreshFilter()
end)

--------------------------------------------------------------------------------
-- EXEC LOG
--------------------------------------------------------------------------------
local execOrder = 0
local function logExec(status, detail, remoteName)
    execOrder = execOrder + 1
    local row = Instance.new("Frame")
    row.Size             = UDim2.new(1, 0, 0, 38)
    row.BackgroundColor3 = T.BG3
    row.BorderSizePixel  = 0
    row.LayoutOrder      = execOrder
    row.Parent           = ExecLogFrame
    corner(row, 4)

    local iconCol = (status == "ok") and T.GREEN or (status == "warn") and T.YELLOW or T.RED
    local icon    = (status == "ok") and "‚úì" or (status == "warn") and "‚ö†" or "‚úï"

    local iconLbl = lbl(row, icon, 14, iconCol, Enum.Font.GothamBold, Enum.TextXAlignment.Center)
    iconLbl.Size     = UDim2.fromOffset(28, 38)
    iconLbl.Position = UDim2.fromOffset(4, 0)

    local nameLbl3 = lbl(row, remoteName or "?", 12, T.TEXT, Enum.Font.GothamSemibold)
    nameLbl3.Size     = UDim2.new(1, -100, 0, 18)
    nameLbl3.Position = UDim2.fromOffset(34, 4)

    local detailLbl = lbl(row, detail or "", 10, T.TEXT_DIM, Enum.Font.Code)
    detailLbl.Size     = UDim2.new(1, -100, 0, 14)
    detailLbl.Position = UDim2.fromOffset(34, 22)

    local tsLbl2 = lbl(row, os.date("%H:%M:%S"), 9, T.TEXT_MUTED, Enum.Font.Code, Enum.TextXAlignment.Right)
    tsLbl2.Size     = UDim2.fromOffset(56, 38)
    tsLbl2.Position = UDim2.new(1, -60, 0, 0)

    ExecLogFrame.CanvasSize     = UDim2.new(0, 0, 0, ExecLogLayout.AbsoluteContentSize.Y + 8)
    ExecLogFrame.CanvasPosition = Vector2.new(0, math.huge)

    local rows  = ExecLogFrame:GetChildren()
    local count = 0
    for _, c in ipairs(rows) do if c:IsA("Frame") then count = count + 1 end end
    if count > MAX_EXEC_LOG then
        for _, c in ipairs(ExecLogFrame:GetChildren()) do
            if c:IsA("Frame") then c:Destroy() break end
        end
    end
end

--------------------------------------------------------------------------------
-- SINGLE FIRE
--------------------------------------------------------------------------------
local function doFire(sel, code)
    if not sel or not sel.remote or not sel.remote.Parent then
        return false, "remote no longer exists"
    end
    local fn, lsErr = loadstring(code or generateCode(sel))
    if fn then
        local ok, runErr = pcall(fn)
        if ok then return true, "loadstring" end
        return false, "runtime: " .. tostring(runErr)
    end
    local ok2, err2 = pcall(function()
        if sel.remoteType == "RemoteFunction" then
            sel.remote:InvokeServer(unsnap(sel.args))
        else
            sel.remote:FireServer(unsnap(sel.args))
        end
    end)
    if ok2 then return true, "direct (" .. (lsErr or "ls disabled") .. ")" end
    return false, "fire error: " .. tostring(err2)
end

--------------------------------------------------------------------------------
-- FIRE BUTTON
--------------------------------------------------------------------------------
FireBtn.MouseButton1Click:Connect(function()
    local now = os.clock()
    if now - spy.lastFire < FIRE_RATE_LIMIT then
        setStatus("‚ö† Rate limited.", T.YELLOW) return
    end
    spy.lastFire = now

    local sel = spy.selected
    if not sel then setStatus("‚ö† No remote selected.", T.YELLOW) return end

    local repeatN  = math.max(1, math.min(tonumber(RepeatBox.Text) or 1, 100))
    local interval = math.max(0, tonumber(IntervalBox.Text) or 0)
    local loopMode = spy.loopRunning

    if spy.loopRunning and spy.loopConn then
        spy.loopConn:Disconnect()
        spy.loopConn    = nil
        spy.loopRunning = false
        LoopToggle.BackgroundColor3 = T.BG3
        LoopToggle.TextColor3       = T.TEXT_DIM
        setStatus("‚óº Loop stopped.", T.TEXT_DIM)
        return
    end

    if loopMode then
        spy.loopRunning = true
        LoopToggle.BackgroundColor3 = T.RED
        LoopToggle.TextColor3       = Color3.new(1,1,1)
        local code = CodeBox.Text
        spy.loopConn = RunService.Heartbeat:Connect(function()
            local ok, detail = doFire(sel, code)
            if not ok then
                spy.loopConn:Disconnect()
                spy.loopConn    = nil
                spy.loopRunning = false
                LoopToggle.BackgroundColor3 = T.BG3
                LoopToggle.TextColor3       = T.TEXT_DIM
                setStatus("‚úï Loop stopped: " .. detail, T.RED)
                logExec("err", detail, sel.remote.Name)
            end
        end)
        setStatus("‚Ü∫ Loop firing: " .. sel.remote.Name, T.GREEN)
        return
    end

    local code = CodeBox.Text
    local fired, failed = 0, 0

    local function fireOnce()
        local ok, detail = doFire(sel, code)
        if ok then fired = fired + 1
        else failed = failed + 1; logExec("err", detail, sel.remote.Name) end
    end

    if interval <= 0 or repeatN == 1 then
        for _ = 1, repeatN do fireOnce() end
        local msg = "‚úì Fired " .. repeatN .. "√ó"
        if failed > 0 then msg = msg .. "  (" .. failed .. " failed)" end
        setStatus(msg, failed > 0 and T.YELLOW or T.GREEN)
        logExec(failed > 0 and "warn" or "ok",
            "√ó" .. repeatN .. (failed > 0 and ("  " .. failed .. " failed") or ""),
            sel.remote.Name)
    else
        local fires = 0
        local function schedNext()
            if fires >= repeatN then
                setStatus("‚úì Repeat done: " .. fired .. "/" .. repeatN,
                    fired < repeatN and T.YELLOW or T.GREEN)
                logExec(fired < repeatN and "warn" or "ok", "√ó" .. repeatN, sel.remote.Name)
                return
            end
            fires = fires + 1
            fireOnce()
            task.delay(interval, schedNext)
        end
        schedNext()
        setStatus("‚Ü∫ Firing " .. repeatN .. "√ó at " .. interval .. "s‚Ä¶", T.BLUE)
    end
end)

--------------------------------------------------------------------------------
-- LOOP TOGGLE
--------------------------------------------------------------------------------
local loopActive = false
LoopToggle.MouseButton1Click:Connect(function()
    loopActive = not loopActive
    if loopActive then
        LoopToggle.BackgroundColor3 = T.RED
        LoopToggle.TextColor3       = Color3.new(1,1,1)
        spy.loopRunning = true
        setStatus("‚Ü∫ Loop mode ON ‚Äî press FIRE to start / stop", T.YELLOW)
    else
        LoopToggle.BackgroundColor3 = T.BG3
        LoopToggle.TextColor3       = T.TEXT_DIM
        spy.loopRunning = false
        if spy.loopConn then
            spy.loopConn:Disconnect()
            spy.loopConn = nil
        end
        setStatus("‚óº Loop mode OFF", T.TEXT_DIM)
    end
end)

--------------------------------------------------------------------------------
-- FIRE ALL SELECTED
--------------------------------------------------------------------------------
FireAllBtn.MouseButton1Click:Connect(function()
    if spy.multiCount == 0 then
        setStatus("‚ö† Ctrl+Click entries to multi-select.", T.YELLOW) return
    end
    local now = os.clock()
    if now - spy.lastFire < FIRE_RATE_LIMIT then
        setStatus("‚ö† Rate limited.", T.YELLOW) return
    end
    spy.lastFire = now

    local delay  = math.max(0, tonumber(MultiDelayBox.Text) or 0)
    local toFire = {}
    for e in pairs(spy.multiSel) do table.insert(toFire, e) end
    local total, fired, failed, skipped = #toFire, 0, 0, 0

    local function fireEntry(entry)
        if not entry.remote or not entry.remote.Parent then
            skipped = skipped + 1
            logExec("warn", "remote gone", entry.remote and entry.remote.Name or "?")
            return
        end
        local ok2, err2 = pcall(function()
            if entry.remoteType == "RemoteFunction" then
                entry.remote:InvokeServer(unsnap(entry.args))
            else
                entry.remote:FireServer(unsnap(entry.args))
            end
        end)
        if ok2 then
            fired = fired + 1
            logExec("ok", "multi-fire", entry.remote.Name)
        else
            failed = failed + 1
            logExec("err", tostring(err2), entry.remote.Name)
        end
    end

    if delay <= 0 then
        for _, e in ipairs(toFire) do task.spawn(fireEntry, e) end
        task.delay(0.06, function()
            setStatus(string.format("‚ö° Multi-fired %d/%d  fail:%d  skip:%d",
                fired, total, failed, skipped),
                failed > 0 and T.YELLOW or T.GREEN)
        end)
    else
        setStatus("‚ö° Firing " .. total .. " with " .. delay .. "s delay‚Ä¶", T.BLUE)
        local idx = 0
        local function nextFire()
            idx = idx + 1
            if idx > #toFire then
                setStatus(string.format("‚ö° Multi-done %d/%d  fail:%d  skip:%d",
                    fired, total, failed, skipped),
                    failed > 0 and T.YELLOW or T.GREEN)
                return
            end
            fireEntry(toFire[idx])
            task.delay(delay, nextFire)
        end
        nextFire()
    end

    FireAllBtn.Text = "‚ö°  FIRING‚Ä¶"
    task.delay(0.8, updateMultiBadge)
end)

--------------------------------------------------------------------------------
-- DESELECT ALL
--------------------------------------------------------------------------------
DeselectBtn.MouseButton1Click:Connect(function()
    clearMulti()
    updateMultiBadge()
    setStatus("‚îÄ‚îÄ Deselected all.", T.TEXT_DIM)
end)

--------------------------------------------------------------------------------
-- COPY CODE
--------------------------------------------------------------------------------
CopyBtn.MouseButton1Click:Connect(function()
    local txt = CodeBox.Text
    if txt == "" then setStatus("‚ö† Nothing to copy.", T.YELLOW) return end
    local ok = false
    if not ok then pcall(function() setclipboard(txt)   ok = true end) end
    if not ok then pcall(function() writeclipboard(txt) ok = true end) end
    if not ok then pcall(function() toclipboard(txt)    ok = true end) end
    if ok then
        local p = CopyBtn.Text
        CopyBtn.Text = "‚úì  COPIED!"
        task.delay(1.2, function() CopyBtn.Text = p end)
        setStatus("‚úì Copied to clipboard.", T.BLUE)
    else
        setStatus("‚úï No clipboard API found.", T.RED)
    end
end)

--------------------------------------------------------------------------------
-- COPY FUNC INFO
--------------------------------------------------------------------------------
CopyFuncBtn.MouseButton1Click:Connect(function()
    local sel = spy.selected
    if not sel then
        setStatus("‚ö† Select a remote first.", T.YELLOW) return
    end
    local txt = generateFuncInfoCode(sel)
    local ok = false
    if not ok then pcall(function() setclipboard(txt)   ok = true end) end
    if not ok then pcall(function() writeclipboard(txt) ok = true end) end
    if not ok then pcall(function() toclipboard(txt)    ok = true end) end
    if ok then
        local p = CopyFuncBtn.Text
        CopyFuncBtn.Text = "‚úì  COPIED!"
        task.delay(1.2, function() CopyFuncBtn.Text = p end)
        setStatus("‚úì Func info + code copied.", T.PURPLE)
    else
        setStatus("‚úï No clipboard API found.", T.RED)
    end
end)

--------------------------------------------------------------------------------
-- BLOCK
--------------------------------------------------------------------------------
BlockBtn.MouseButton1Click:Connect(function()
    if spy.selected then
        local name = spy.selected.remote.Name
        spy.blocked[name] = true
        local p = BlockBtn.Text
        BlockBtn.Text = "‚äò  BLOCKED!"
        task.delay(1, function() BlockBtn.Text = "‚äò  BLOCK REMOTE" end)
        setStatus("‚äò Blocked: " .. name, T.ORANGE)
    else
        setStatus("‚ö† Select a remote first.", T.YELLOW)
    end
end)

--------------------------------------------------------------------------------
-- CLEAR
--------------------------------------------------------------------------------
ClearBtn.MouseButton1Click:Connect(function()
    for _, c in ipairs(LogFrame:GetChildren()) do
        if c:IsA("TextButton") then c:Destroy() end
    end
    spy.entries       = {}
    spy.entryMap      = {}
    spy.selected      = nil
    spy.multiSel      = {}
    spy.multiCount    = 0
    spy.totalCalls    = 0
    pendingLogs       = {}
    CodeBox.Text      = ""
    showFuncInfo(nil)
    updateCountLbl()
    updateMultiBadge()
    setStatus("‚îÄ‚îÄ Logs cleared ‚îÄ‚îÄ", T.TEXT_DIM)
end)

--------------------------------------------------------------------------------
-- PAUSE
--------------------------------------------------------------------------------
PauseBtn.MouseButton1Click:Connect(function()
    spy.paused = not spy.paused
    if spy.paused then
        PauseBtn.Text              = "‚ñ∂"
        PausedBadge.Visible        = true
        StatusDot.BackgroundColor3 = T.ORANGE
        setStatus("‚è∏ Paused ‚Äî no new events will be logged.", T.ORANGE)
    else
        PauseBtn.Text              = "‚è∏"
        PausedBadge.Visible        = false
        StatusDot.BackgroundColor3 = T.GREEN
        setStatus("‚ñ∂ Resumed.", T.GREEN)
    end
end)

--------------------------------------------------------------------------------
-- MINIMIZE
--------------------------------------------------------------------------------
local isMin = false
MinBtn.MouseButton1Click:Connect(function()
    isMin = not isMin
    if isMin then
        tweenProp(Main, {Size = UDim2.fromOffset(WIN_W, 40)}, 0.2)
        MinBtn.Text    = "‚ñ°"
        Body.Visible   = false
        TabBar.Visible = false
    else
        Body.Visible   = true
        TabBar.Visible = true
        tweenProp(Main, {Size = UDim2.fromOffset(WIN_W, WIN_H)}, 0.2)
        MinBtn.Text    = "‚îÄ"
    end
end)

--------------------------------------------------------------------------------
-- KEYBOARD SHORTCUTS
--------------------------------------------------------------------------------
UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    local ctrl = UserInputService:IsKeyDown(Enum.KeyCode.LeftControl)
             or  UserInputService:IsKeyDown(Enum.KeyCode.RightControl)

    if ctrl and input.KeyCode == Enum.KeyCode.A then
        clearMulti()
        for _, e in ipairs(spy.entries) do
            if e.btn and e.btn.Parent and e.btn.Visible then
                addMulti(e)
                e.btn.BackgroundColor3 = T.ENTRY_MULTI
            end
        end
        updateMultiBadge()
        setStatus("‚ö° Selected all " .. spy.multiCount .. " visible entries", T.BLUE)

    elseif ctrl and input.KeyCode == Enum.KeyCode.D then
        clearMulti()
        updateMultiBadge()
        setStatus("‚îÄ‚îÄ Deselected all.", T.TEXT_DIM)

    elseif input.KeyCode == Enum.KeyCode.Delete and spy.selected then
        local name = spy.selected.remote.Name
        spy.blocked[name] = true
        if spy.selected.btn and spy.selected.btn.Parent then
            spy.selected.btn:Destroy()
        end
        for i, e in ipairs(spy.entries) do
            if e == spy.selected then table.remove(spy.entries, i) break end
        end
        spy.selected = nil
        CodeBox.Text = ""
        showFuncInfo(nil)
        setStatus("‚äò Blocked (Delete): " .. name, T.ORANGE)
    end
end)

--------------------------------------------------------------------------------
-- DIVIDER DRAG
--------------------------------------------------------------------------------
local divDragging = false
local divDragStart = 0
local divStartW    = logPanelW

DivHandle.MouseButton1Down:Connect(function()
    divDragging  = true
    divDragStart = UserInputService:GetMouseLocation().X
    divStartW    = LogPanel.AbsoluteSize.X
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        divDragging = false
    end
end)

RunService.RenderStepped:Connect(function()
    if not divDragging then return end
    local mx   = UserInputService:GetMouseLocation().X
    local dx   = mx - divDragStart
    local newW = math.clamp(divStartW + dx, 250, WIN_W - 220)
    LogPanel.Size      = UDim2.new(0, newW, 1, 0)
    Divider.Position   = UDim2.fromOffset(newW, 0)
    CtrlPanel.Size     = UDim2.new(1, -(newW + 5), 1, 0)
    CtrlPanel.Position = UDim2.fromOffset(newW + 5, 0)
end)

--------------------------------------------------------------------------------
-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
--  HOOK ENGINE  v5.2  ‚Äî  ALL FIXES APPLIED
-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
--
--  FIX 1: Removed checkcaller() guard.
--          The old code had:
--              if not checkcaller or not checkcaller() then ... end
--          Inside a hookmetamethod callback, checkcaller() can return TRUE
--          for real game scripts on many executors, meaning the guard
--          silently dropped the majority of legitimate remote calls.
--          REMOVED entirely ‚Äî the hook already only runs for FireServer/
--          InvokeServer methods so there is no need to gate on checkcaller.
--
--  FIX 2: getrawmetatable fallback.
--          If hookmetamethod is not available, we now manually patch
--          game's __namecall via getrawmetatable + setreadonly.
--
--  FIX 3: hookfunction() backup on FireServer / InvokeServer directly.
--          This catches any calls that bypass __namecall (e.g. stored refs).
--
--  FIX 4: Case variants ‚Äî "fireServer" and "invokeServer" are now checked
--          in addition to the Pascal-cased versions.
--
--  FIX 5: Function info is captured at hook time via debug.info / debug.getinfo
--          and stored on the entry for display in the Function Info panel.
-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

local outgoingHooked = false
local originalNamecall = nil

-- ‚îÄ‚îÄ Namecall handler (shared by both hook strategies) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
local function handleNamecall(self, ...)
    if typeof(self) ~= "Instance" then
        return originalNamecall(self, ...)
    end

    local method = (getnamecallmethod and getnamecallmethod()) or ""

    local isFireServer   = method == "FireServer"   or method == "fireServer"
    local isInvokeServer = method == "InvokeServer" or method == "invokeServer"

    if isFireServer or isInvokeServer then
        local isRE = pcall(function() return self:IsA("RemoteEvent")   end) and self:IsA("RemoteEvent")
        local isRF = pcall(function() return self:IsA("RemoteFunction") end) and self:IsA("RemoteFunction")

        if (isFireServer and isRE) or (isInvokeServer and isRF) then
            -- FIX 1: NO checkcaller() guard here
            -- FIX 5: capture function info at hook time
            local fi = {}
            pcall(function() fi = captureFuncInfo() end)

            local argSnap = snap(...)
            local rtype   = isRF and "RemoteFunction" or "RemoteEvent"

            -- queue the log (non-blocking)
            task.defer(function()
                addLog(self, argSnap, rtype, "OUT", fi)
            end)
        end
    end

    return originalNamecall(self, ...)
end

-- ‚îÄ‚îÄ Strategy A: hookmetamethod (best, if available) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if hookmetamethod then
    local ok, err = pcall(function()
        originalNamecall = hookmetamethod(game, "__namecall", function(self, ...)
            return handleNamecall(self, ...)
        end)
    end)
    if ok then
        outgoingHooked = true
        print("[RemoteSpy v5.2] hookmetamethod: outgoing captured.")
    else
        warn("[RemoteSpy v5.2] hookmetamethod failed:", err)
    end
end

-- ‚îÄ‚îÄ Strategy B: getrawmetatable fallback (if hookmetamethod missing) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if not outgoingHooked and getrawmetatable and setreadonly then
    local ok, err = pcall(function()
        local gm = getrawmetatable(game)
        originalNamecall = gm.__namecall
        setreadonly(gm, false)
        gm.__namecall = (newcclosure and newcclosure(handleNamecall) or handleNamecall)
        setreadonly(gm, true)
    end)
    if ok then
        outgoingHooked = true
        print("[RemoteSpy v5.2] getrawmetatable fallback: outgoing captured.")
    else
        warn("[RemoteSpy v5.2] getrawmetatable fallback failed:", err)
    end
end

-- ‚îÄ‚îÄ Strategy C: hookfunction directly on FireServer / InvokeServer ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
-- This catches calls that bypass __namecall entirely (stored function refs)
if hookfunction then
    pcall(function()
        local _re = Instance.new("RemoteEvent")
        local _rf = Instance.new("RemoteFunction")
        local origFire   = _re.FireServer
        local origInvoke = _rf.InvokeServer
        _re:Destroy()
        _rf:Destroy()

        hookfunction(origFire, newcclosure and newcclosure(function(self, ...)
            -- FIX 1: NO checkcaller guard
            local fi = {}
            pcall(function() fi = captureFuncInfo() end)
            task.defer(addLog, self, snap(...), "RemoteEvent", "OUT", fi)
            return origFire(self, ...)
        end) or function(self, ...)
            local fi = {}
            pcall(function() fi = captureFuncInfo() end)
            task.defer(addLog, self, snap(...), "RemoteEvent", "OUT", fi)
            return origFire(self, ...)
        end)

        hookfunction(origInvoke, newcclosure and newcclosure(function(self, ...)
            local fi = {}
            pcall(function() fi = captureFuncInfo() end)
            task.defer(addLog, self, snap(...), "RemoteFunction", "OUT", fi)
            return origInvoke(self, ...)
        end) or function(self, ...)
            local fi = {}
            pcall(function() fi = captureFuncInfo() end)
            task.defer(addLog, self, snap(...), "RemoteFunction", "OUT", fi)
            return origInvoke(self, ...)
        end)

        print("[RemoteSpy v5.2] hookfunction: backup FireServer/InvokeServer hooked.")
    end)
end

-- ‚îÄ‚îÄ Incoming: OnClientEvent / OnClientInvoke ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
local function hookIncoming(obj)
    if not obj or not obj.Parent then return end
    if spy.hooked[obj] then return end

    if obj:IsA("RemoteEvent") then
        spy.hooked[obj] = true
        local ok, err = pcall(function()
            obj.OnClientEvent:Connect(function(...)
                if obj and obj.Parent then
                    addLog(obj, snap(...), "RemoteEvent", "IN", nil)
                end
            end)
        end)
        if not ok then
            spy.hooked[obj] = nil
            warn("[RemoteSpy v5.2] RE hook failed:", obj:GetFullName(), err)
        end

    elseif obj:IsA("RemoteFunction") then
        spy.hooked[obj] = true
        local ok, err = pcall(function()
            local original = obj.OnClientInvoke
            obj.OnClientInvoke = function(...)
                addLog(obj, snap(...), "RemoteFunction", "IN", nil)
                if original then return original(...) end
            end
        end)
        if not ok then
            spy.hooked[obj] = nil
            warn("[RemoteSpy v5.2] RF hook failed:", obj:GetFullName(), err)
        end
    end
end

-- Initial scan
local hookedCount = 0
for _, v in ipairs(game:GetDescendants()) do
    local was = not spy.hooked[v]
    hookIncoming(v)
    if was and spy.hooked[v] then hookedCount = hookedCount + 1 end
end
print(string.format("[RemoteSpy v5.2] Hooked %d existing remotes (incoming).", hookedCount))

game.DescendantAdded:Connect(function(obj)
    task.defer(function() hookIncoming(obj) end)
end)

game.DescendantRemoving:Connect(function(obj)
    if spy.hooked[obj] then spy.hooked[obj] = nil end
end)

--------------------------------------------------------------------------------
-- STARTUP STATUS
--------------------------------------------------------------------------------
local startMsg = "‚óâ Active"
    .. (outgoingHooked
        and "  |  ‚Üí Outgoing + ‚Üê Incoming"
        or  "  |  ‚Üê Incoming only (no namecall hook)")
setStatus(startMsg, T.GREEN)
print("[RemoteSpy v5.2] Ready. Outgoing:", outgoingHooked)
